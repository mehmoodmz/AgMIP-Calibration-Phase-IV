# Install and load the needed libraries
if(!require("here")){
  install.packages("here")
  library("here")
}
source(file.path(here(),"R/install_load.r"))
install_load()

################################################################################
###### Initialization step => tp be adapted to your case #######################

# DEBUG mode (set to TRUE to to test the protocol with limited number of situations, repetitions and evaluations, 
#                    FALSE otherwise)
debug <- TRUE

# Define the test case ("French" or "Australian") and variety (only used for French dataset)
test_case <- "French"
variety <- "Bermude"  # "Apache" or "Bermude"
test_case <- "Australian"
variety <- "Janz"

# Set-up your model wrapper
## Give here the name of your model (just used for naming some output files)
model_name <- "my_model_name"
## Source the file including your model wrapper
source("path_to_my_model_wrapper")
## Give here the link to your model wrapper function  
model_wrapper <- my_model_wrapper_function

# Define model_options depending on your model wrapper
model_options <- 

# Give here the type of reference date used for computing julian days for phenological stage
# should be equal to "SowingYear" if julian days are computed from the beginning of the sowing year
# or "SowingDate" if julian days are computed from the sowing date
descr_ref_date <- "SowingYear"

# Define model output transformation(s) if necessary.
# Useful if one (or several) observed variable is not directly comparable to a 
# simulated one but if one can compute an equivalent from the simulated variables.
# In the following example, N_in_biomassHarvest (observed in French dataset) is not 
# directly computed by the model.
# The model simulates a variable, called QNplante, which is the N in biomass in kg ha-1, 
# and the biomass, called masec_n, in t ha-1.
# N_in_biomassHarvest (in %) can be computed from these simulated variables,
# by dividing QNplante by (masec_n*10).
# To do that, we created a transform_sim function that will be automatically run after each 
# model simulations in estim_param.
# If you define a transform_sim function, list in tranform_outputs the variables 
# generated by transform_sim, and in tranform_inputs those required in input of 
# transform_sim to compute them.
# If no transformation required, let transform_sim, transform_outputs and transform_inputs 
# to NULL
transform_sim <- NULL
transform_outputs <- NULL
transform_inputs <- NULL
# if (test_case=="French") {
#   transform_sim <- function(model_results, ...) {
#     
#     # Create the new variable for each situation included in model_results$sim_list
#     for (sit in names(model_results$sim_list)) {
#       model_results$sim_list[[sit]]$N_in_biomassHarvest <- 
#         model_results$sim_list[[sit]]$QNplante / (10 * model_results$sim_list[[sit]]$masec_n)
#     }
#     return(model_results)  
#   }
#   
#   transform_outputs <- c("N_in_biomassHarvest")
#   transform_inputs <- c("QNplante")
#   
# }

###### end of initialization step => the following should not be changed #######
################################################################################


set.seed(seed)

# Load the protocol description file (xls file) 
protocol_descr <- load_protocol(xls_path, transform_outputs, use_obs_synth, beta)
sitNames_corresp <- protocol_descr$sitNames_corresp 
varNames_corresp <- protocol_descr$varNames_corresp 
simVar_units <- protocol_descr$simVar_units 
param_info <- protocol_descr$param_info
forced_param_values <- protocol_descr$default_param_values 
param_group <- protocol_descr$param_group # list of params to estimate per group
obsVar_group <- protocol_descr$obsVar_group # groups of observed variables used in the calibration
converted_obsVar_group <- setNames(obsVar_group,nm=varNames_corresp[names(obsVar_group)])													  
true_param_values <- protocol_descr$true_param_values 		   

# Load the observations
suffix <- NULL
if (test_case=="French") suffix <- paste0("_",variety)
if (test_case=="Australian" & data_without_Minnipa) {
  obs_data_folder <- "data_without_Minnipa"
} else {
  obs_data_folder <- "data"
}
obs_data_path <- file.path(here(),obs_data_folder,paste0("cal_4_obs_",test_case,suffix,".txt"))
obs_unit_path <- file.path(here(),obs_data_folder,paste0("cal_4_obs_",test_case,"_units.csv"))
obs <- load_obs(obs_data_path, obs_unit_path, varNames_corresp,
                sitNames_corresp, simVar_units, obsVar_group)

obs_list <- obs$obs_list  # list of observation as defined in the observation file
obsVar_names <- obs$obsVar_names # Names of the observed variables as defined in the observation file
obsVar_units <- obs$obsVar_units # Units of the observed variables as defined in the observation file
obsVar_used <- obs$obsVar_used # NAmes of the observed variables used in the current protocol application
converted_obs_list <- obs$converted_obs_list # list of observation in th emodel space (i.e. with name of situation and variables as in the model_wrapper, and units as defined in model outputs)
sowing_jul_obs <- obs$sowing_jul_obs

# Get the list of variables for which the user must provide 
# results in the cal_4_results_***.txt file)
template_path <- file.path(here(),"data",paste0("cal_4_results_",test_case,suffix,"_numerical_modelName_contact_person.txt"))
template_df <- read.table(template_path,
                          header = TRUE, stringsAsFactors = FALSE)
resVar_names <- setdiff(names(template_df),c("Number","Site","HarvestYear",
                                             "Date_sowing", "SowingDate",
                                             "Variety","Date"))

## Check that the list of "observed and required variables" as defined in the protocol 
## description xls file is included in the union of observed and required variables
## as they are defined in the cal_4_obs and cal_4_reslts files.
if (!all(names(varNames_corresp) %in% unique(c(obsVar_names, resVar_names)))) 
  stop(paste0("Unknown variable(s) ",
              paste(setdiff(names(varNames_corresp), unique(c(obsVar_names, resVar_names))), collapse = ","), 
              "\nPlease modify sheet \"variables\", column \"Name of the observed or required variable\" of the file:\n",
              xls_path,
              "\nThe variables included in this column must be included in the list of variables defined in files:\n",
              template_path, "\nand\n",obs_data_path))

# Compute the list of required variables in output of the wrapper
# (list of variables for which there is a correspondance with observed and results variables + 
#  transform_inputs - transform_outputs)
reqVar_Wrapper <- setdiff(c(varNames_corresp,transform_inputs),transform_outputs)

sim_true <- NULL				
if (use_obs_synth) {
  
  obs_synth <- generate_obs_synth(true_param_values=c(true_param_values), 
                                  model_wrapper, 
                                  model_options, sitNames_corresp, 
                                  reqVar_Wrapper, converted_obs_list, transform_sim,
                                  simVar_units, varNames_corresp, obsVar_units,  
                                  obs_list, obsVar_used, noise_sd, descr_ref_date,
                                  flag_eos)									
  obs_list <- obs_synth$obs_list
  converted_obs_list <- obs_synth$converted_obs_list
  sim_true <- obs_synth$sim_true								
  
} 


# In debug mode reduce number of evaluations, situations, repetitions, candidate parameters, ...
if (debug) {
  cat("\nDebug mode ...\n")
  sit_list <- names(converted_obs_list)[1:6]
  converted_obs_list <- filter_obs(converted_obs_list,
                                       situation = sit_list,
                                       include=TRUE)
  obs_list <- filter_obs(obs_list,
                         situation = names(obs_list)[1:6],
                         include=TRUE)  
  for (gr in names(param_group)) { # only keep the 1st candidate
    if (!is.null(param_group[[gr]]$candidates)) 
      param_group[[gr]]$candidates <- param_group[[gr]]$candidates[1]
  }

}

# Save configuration
save.image(file=file.path(out_dir,"config.Rdata"))


# Initialize some local variables 
flag_checkpoint <- FALSE
igr <- 0
res_it1 <- list(); res_it1_tmp <- NULL; res_it2 <- NULL; 
weight_it2 <- NULL; 
complem_info <- list(it1=list(), it2=list())

if (file.exists(file.path(out_dir,"checkpoint.Rdata"))) load(file.path(out_dir,"checkpoint.Rdata"))


# Evaluate performances using default values of the parameters

sim_default <- run_wrapper(model_wrapper=model_wrapper,
                           model_options=model_options,
                           param_values=c(forced_param_values),
                           situation=sitNames_corresp, var=reqVar_Wrapper, 
                           obs_list=converted_obs_list,
                           transform_sim=transform_sim, transform_var=NULL)
sim_list_default_converted <- convert_and_rename(sim_default$sim_list, sitNames_corresp, simVar_units, 
                                           varNames_corresp, obsVar_units)
p <- plot(sim_list_default_converted, obs=obs_list, type="scatter")
CroPlotR::save_plot_pdf(p, out_dir, file_name = "scatterPlots_default")
# Parameter Estimation, first iteration

cat("\n----- Parameter estimation Iteration 1\n")
cat("--------------------------------------\n")

transform_var <- eval(parse(text=paste0("c(",varNames_corresp[["Biomass"]],
                                        "=function(x) log(x+.Machine$double.xmin))")))

crt_forced_param_values <- forced_param_values
while (igr < length(param_group)) {
  
  igr <- igr+1
  gr <- names(param_group)[igr]
  cat(paste("\n---------------- Group",gr,"\n"))
  
  ## Filter observations to use for the current group
  crt_var_list <- varNames_corresp[intersect(obsVar_used,
                                             names(obsVar_group)[grep(gr, obsVar_group)])]
  crt_obs_list <- filter_obs(obs_list=converted_obs_list, var=crt_var_list, include=TRUE)
  
  ## Filter information on the parameters to estimate for the current group
  crt_params <- c(param_group[[gr]]$obligatory, param_group[[gr]]$candidates)
  crt_param_info <- lapply(param_info,function(x) x[crt_params])

  ## Define parameters to force (estimated values for the parameters previously selected,
  ##                            default values for the others, exclude the current candidate 
  ##                            parameters)
  if (!is.null(res_it1_tmp)) {
    param_to_add <- setdiff(names(forced_param_values), names(crt_forced_param_values))
    crt_forced_param_values <- c(forced_param_values[param_to_add], crt_forced_param_values)
    crt_forced_param_values[names(res_it1_tmp$final_values)] <- res_it1_tmp$final_values
  }
  crt_forced_param_values[param_group[[gr]]$obligatory] <- NULL
  
  # Optimization options (depends on the number of obligatory parameters)
  # Define number of repetitions and evaluations
  nb_rep_it1 <- c(10,5)
  if (length(param_group[[gr]]$obligatory)>1) nb_rep_it1 <- c(20,5)
  maxeval <- 50000
  if (debug) {
    nb_rep_it1 <- c(1,1)
    maxeval=10
  }
  optim_options=list(nb_rep=nb_rep_it1, maxeval=maxeval, ranseed=seed, xtol_rel=1e-4, 
                     ftol_rel=1e-4, 
                     out_dir=file.path(out_dir,"Iteration1",paste0("group_",gr)))
  
  crit_function <- function(sim_list, obs_list) {
    crit <- crit_ols(sim_list, obs_list)
    if ( !(crt_var_list[1] %in% names(transform_var)) ) {
      units(crit) <- paste(simVar_units[[crt_var_list[1]]],
                           simVar_units[[crt_var_list[1]]])
      units(crit) <- paste(obsVar_units[[convert_name(crt_var_list[1],varNames_corresp)]],
                           obsVar_units[[convert_name(crt_var_list[1],varNames_corresp)]])
      crit <- drop_units(crit)
    }
    return(crit)
  }
  res_it1_tmp <- estim_param(obs_list=crt_obs_list, 
                     crit_function = crit_function,
                     model_function=model_wrapper,
                     model_options=model_options,
                     optim_options=optim_options,
                     param_info=crt_param_info, candidate_param=param_group[[gr]]$candidates,
                     forced_param_values=crt_forced_param_values, 
                     transform_var=transform_var,
                     transform_sim=transform_sim, var=reqVar_Wrapper,
                     info_crit_func = list(CroptimizR::AICc, CroptimizR::BIC))
  
  # Run model wrapper using parameter values estimated at this step
  sim_it1_tmp <- run_wrapper(model_wrapper = model_wrapper,
                             model_options=model_options,
                             param_values=c(res_it1_tmp$final_values, 
                                            res_it1_tmp$forced_param_values),
                             situation=sitNames_corresp, var=reqVar_Wrapper, 
                             obs_list=crt_obs_list,
                             transform_sim=transform_sim, transform_var=NULL)
  
  # ScatterPlots simulations VS obs at this step
  sim_list_it1_tmp_converted <- convert_and_rename(sim_it1_tmp$sim_list, sitNames_corresp, simVar_units, 
                                                   varNames_corresp, obsVar_units)
  p <- plot(sim_list_it1_tmp_converted, obs=obs_list, type="scatter")
  CroPlotR::save_plot_pdf(p, optim_options$out_dir, 
                          file_name = paste0("scatterPlots_it1_",gr))
  res_it1[[gr]] <- res_it1_tmp
  
  save(sim_default, res_it1_tmp, res_it1, igr, crt_forced_param_values, 
       file = file.path(out_dir,paste0("checkpoint_it1_gr",igr,".Rdata")))
  
  complem_info$it1[[gr]] <- list(forced_param_values=unlist(crt_forced_param_values),
                                 obsVar_used=crt_var_list,
                                 crt_obs_list=crt_obs_list)
  save(complem_info, 
       file = file.path(out_dir,paste0("complementary_info.Rdata")))
  
}

# List of parameters selected after iteration 1, estimated values and forced parameters
final_params <- unlist(lapply(names(param_group), function(x) names(res_it1[[x]]$final_values)))
res_it1$final_values <- setNames(object=unlist(lapply(names(param_group), 
                                                      function(x) res_it1[[x]]$final_values)),
                                 nm=final_params)
last_forced_param_values <- res_it1[[names(param_group)[length(param_group)]]]$forced_param_values
res_it1$forced_param_values <- last_forced_param_values[setdiff(names(last_forced_param_values),
                                                                final_params)]
# Run model wrapper using parameter values estimated in iteration 1
sim_it1 <- run_wrapper(model_wrapper = model_wrapper,
                       model_options=model_options,
                       param_values=c(res_it1$final_values, 
                                      res_it1$forced_param_values),
                       situation=sitNames_corresp, var=reqVar_Wrapper, 
                       obs_list=converted_obs_list,
                       transform_sim=transform_sim, transform_var=NULL)

# ScatterPlots simulations VS obs after it1
sim_list_it1_converted <- convert_and_rename(sim_it1$sim_list, sitNames_corresp, simVar_units, 
                                             varNames_corresp, obsVar_units)
p <- plot(sim_list_it1_converted, obs=obs_list, type="scatter")
CroPlotR::save_plot_pdf(p, out_dir, file_name = "scatterPlots_it1")

save(sim_default, res_it1, sim_it1, igr, crt_forced_param_values, 
     file = file.path(out_dir,paste0("checkpoint_it1_final.Rdata")))



# Parameter Estimation, Second iteration

cat("\n----- Parameter estimation Iteration 2\n")
cat("--------------------------------------\n")

nb_rep_it2 <- 20
maxeval <- 50000
if (debug) {
  nb_rep_it2 <- 1
  maxeval=10
}
optim_options=list(nb_rep=nb_rep_it2, maxeval=maxeval, ranseed=seed, xtol_rel=1e-4, ftol_rel=1e-4)

# List of parameters to estimate as selected in iteration 1
final_params <- names(res_it1$final_values)
final_param_info <- lapply(param_info,function(x) x[final_params])

# Use estimated values of iteration 1 as initial values for 1st repetition
final_param_info$init_values <- res_it1$final_values

## Define parameters to force (defaults values for all non-selected parameters)
final_forced_param_values <- forced_param_values[setdiff(names(forced_param_values),
                                                         final_params)]

if (is.null(res_it2)) {
 
  optim_options$out_dir <- file.path(out_dir,"Iteration2")

  # Define the criterion to minimize
  ## apply transformation to sim_it1 first
  sim_it1_transformed <- apply_transform_var(sim_it1$sim_list, transform_var)				
  crit_function <- function(sim_list, obs_list) {
    
    stats <- summary(sim_it1_transformed, obs=obs_list, stats = c("n_obs","SS_res")) 
    groups<-converted_obsVar_group[stats$variable]
    stats <- mutate(stats, 
                    p = sapply(groups,function(x) length(res_it1[[x]]$final_values)))
    
    weight <- sqrt(stats$SS_res/(stats$n_obs-stats$p))
    alpha <- 1
    weight_it2 <<- unique(bind_rows(weight_it2,alpha*weight[names(weight)!="Date"]))
    crit_wls(sim_list, obs_list, 
             weight=weight,
             alpha=alpha)
  }
  
  res_it2 <- estim_param(obs_list=converted_obs_list, 
                         crit_function = crit_function,
                         model_function=model_wrapper,
                         model_options=model_options,
                         optim_options=optim_options,
                         param_info=final_param_info,
                         forced_param_values=final_forced_param_values,
                         transform_var=transform_var,
                         transform_sim=transform_sim, var=reqVar_Wrapper)

  # Run model wrapper using parameter values estimated in iteration 2
  sim_it2 <- run_wrapper(model_wrapper = model_wrapper,
                         model_options=model_options,
                         param_values=c(res_it2$final_values, res_it2$forced_param_values),
                         situation=sitNames_corresp, var=reqVar_Wrapper, 
                         obs_list=converted_obs_list,
                         transform_sim=transform_sim, transform_var=NULL)
  
  # ScatterPlots simulations VS obs after it2
  sim_list_it2_converted <- convert_and_rename(sim_it2$sim_list, sitNames_corresp, simVar_units, 
                                               varNames_corresp, obsVar_units)
  p <- plot(sim_list_it2_converted, obs=obs_list, type="scatter")
  CroPlotR::save_plot_pdf(p, out_dir, file_name = "scatterPlots_it2")
  
  
  save(sim_default, res_it1, sim_it1, igr, res_it2, sim_it2, 
       file = file.path(out_dir,paste0("checkpoint_it2.Rdata")))
  
  complem_info$it2 <- list(forced_param_values=unlist(final_forced_param_values),
                           obsVar_used=varNames_corresp[varNames_corresp %in% unlist(lapply(converted_obs_list,names))],
                           converted_obs_list=converted_obs_list,
                           weight=weight_it2, sim_it1=sim_it1)
  save(complem_info, 
       file = file.path(out_dir,paste0("complementary_info.Rdata")))
  
}



# Generating diagnostics and results files using CroPlotR

suffix <- NULL
if (test_case=="French") suffix <- paste0("_",variety) 
generate_results_files(param_group, model_options,  
                       complem_info, res_it2, 
                       sitNames_corresp, 
                       sim_default, sim_it1, sim_it2, 
                       obs_list, converted_obs_list,
                       obsVar_units, obsVar_used, 
                       template_path, out_dir, test_case, variety,
                       varNames_corresp, resVar_names, 
                       forced_param_values, use_obs_synth=use_obs_synth, 
                       sim_true=sim_true, 
                       descr_ref_date=descr_ref_date, flag_eos=flag_eos)
# Copying script and protocol files in result folder
file.copy(from=xls_path, to=out_dir, overwrite = TRUE)
file.copy(from=rstudioapi::getSourceEditorContext()$path, to=out_dir, overwrite = TRUE)

# Displaying Results
cat("\n----------------------\n")
cat("Final values of estimated parameters:\n")
print(res_it2$final_values)
cat("\nFixed values of the other parameters:\n")
print(res_it2$forced_param_values)

cat(paste("\nResults Tables and files required in Phase IV protocol as well as detailed additional results can be found in folder:",out_dir))

# Displaying Total time
cat("\nTotal time of parameter estimation process:\n")
cat(paste("    Iteration 1:", sum(sapply(names(param_group), function(gr) res_it1[[gr]]$total_time))/3600, "hours elapsed\n"))
cat(paste("    Iteration 2:", res_it2$total_time/3600, "hours elapsed\n"))
cat(paste("    Total:", 
          (sum(sapply(names(param_group), function(gr) res_it1[[gr]]$total_time)) + 
             res_it2$total_time)/3600, 
          "hours elapsed\n"))
cat("----------------------\n")


if (debug) {
  cat("\n----------------------\n")
  cat("WARNING: the protocol has been applied in DEBUG mode on a sublist of situations and with limited number of repetitions and evaluations.")
  cat("Set debug to FALSE in the main script to disable DEBUG mode.")
  cat("\n----------------------\n")
}

if (flag_checkpoint) {
  cat("\n----------------------\n")
  cat(paste("WARNING: the protocol has been applied in RESTART mode using the file:",
            file.path(out_dir,"checkpoint.Rdata")))
  cat("Change the name of this file to disable RESTART mode.")
  cat("\n----------------------\n")
}
